---
layout: "../../layouts/BlogPost.astro"
title: "Astro + React + Tailwind CSSで個人ウェブサイトをリニューアル"
description: "Tailwind CSSが結構楽しい"
pubDate: "2022/10/25"
heroImage: "/lab/member/2109/images/old-website.png"
---

# クソださウェブサイト

以前のゼミ用ウェブサイトは流石にダサすぎた。00年代のイラストレーターの個人サイトやポートフォリオでももう少しまともなデザインをしていただろうってくらいにダサすぎた。アクセスカウンターすら埋め込もうとしていない（まあ要らない）し、かつてのIEでもほぼ同じように表示できたんじゃないかというくらいにシンプルだった。

ダサいと言っても、単にHTMLのタグやCSSのプロパティを全然使いこなせていないとかそういう理由でダサかったわけではない。コンテンツが中央によるようにマージンを設定していた。Windows標準のイマイチなフォントが表示されないよう、フォントも自分で指定していた。コードブロックはちゃんとモノスペースのフォントファミリーを設定した。ウェブ技術に苦手意識をもつ私なりに、最低限のクオリティを担保した。しかし、所詮は見た目に気を使わないオタク気質な私が作ったウェブサイトだった。全然使いこなせないわけではないというが、白と黒以外の色をウェブサイトに使う気がさっぱりなく、様々な部分で作りが甘かった。服だけは妙に小慣れている気がするけど髪型がダサすぎる、みたいな感じ。

しかし、ここ最近インターンシップ参加などを通じて、このあたりの技術にある程度詳しくなれたので、練習とさらなる技術力の向上を狙って個人ウェブサイトを改修することに決めた。

# 使用する技術

ウェブサイトを改修するに当たり、どの技術を選定するかは様々な楽しさがある。仕事であれば要求仕様と突き合わせたりコストや工数を見積もったりするが、これは私の個人的なプロジェクトであり1円にもならない作業なので、私が最近注目しているフレームワークや個人的に使い慣れているものを使っていくことにした。

メインで使うのは記事のタイトルに上がっているこの3つになるわけだが。

## Astro

https://astro.build

今回の主役である。今回採用している他の技術スタックの中では新し目のプロジェクトのようで、私も最近知った。英語の情報はまだまだ少なく、日本語の情報など皆無だが、静的ウェブサイトを手軽に作るにはなかなか扱いやすいフレームワークなんじゃないかと思い、使ってみることにした。

なんといっても、静的ウェブサイトの構築に特化して、サイト生成の際に極力JavaScriptを排除しようとする設計思想が特徴だろう。公式サイトではAstro Islands Architectureと表現され、ウェブサイトのうち必要な部分にだけJavaScriptを実行させるようにビルドの段階で最適化してくれる。

Create React AppおよびNext.jsはクライアントサイドでのJavaScriptの実行を前提とした上で、ユーザにコンテンツを展開する。HTMLウェブページとスタイルシート、スクリプトを一旦サーバから受け取ったら、それ以降のデータのやり取りは別のHTMLページでなくAPI通信で行う。これはよくSPA (Single Page Application)と表現される。ブラウザで動く様々なアプリは、ブラウザ上でスクリプトを実行し、必要なデータなどはAPI通信でやり取りすることで、ページを書き換えている。

対して、Astroは単一のページでなく複数のページを作り、サーバ側でルーティングを処理する。Astroのページをホストするサーバでは公開フォルダが作成され、そこにウェブページのデータが配置される。この方式は実装や簡単でサーバ・クライアントともに要求されうスペックが非常に低い。ただその分、インタラクティブなUIを構築しようとすると制限がかかってしまう。

私としては、たかが個人ウェブサイトに単一ページでリッチなUIを持たせる必要もないし、そもそもゼミのウェブサイトというプラットフォームはPHP以外非対応なので、そこまでなにか重厚なコンテンツを作る気になれなかった。要するに、「Astroほどの軽量なウェブサイトで十分」と思った。管理者権限やターミナルもいじれない上に、Nginxの設定ファイルも触らせてもらえないので、やれることはそんなに多くなかった。

## React

Astroは部分的にJavaScriptを取り込ませることができる。そこまでインタラクティブなものを開発する気はないが、かといってReactは結構便利だった。特にヘッダーなどのUIコンポーネントを記述するのによさそうだと思ったので、今回はReactも導入した。

Astroはその他のフレームワークと統合することができる。このあと紹介するTailwind CSSも使えるし、React以外のUIフレームワークも使える。それどころか複数のフレームワークでできたUIを混ぜ込んで使うこともできる。何か作成したいコンポーネントがあり、インターネットでコード例を検索したところ、メインとしているフレームワークと違うフレームワークで書かれたものが見つかったので、それをコピペで流用したい、ぐらいしか活きる場面が思いつかない。

今回はまさかの物理サーバへのデプロイだったので必要なかったが、各種クラウドサービスにデプロイするためのアダプターなども提供されている。

個人的に、宣言的UIの利便性を徐々に感じ始めてはいる。例えばPythonやJava、バニラのJavaScriptでUIを構築しようとすると、コードが複雑になりすぎていたが、Reactなどであれば複雑にはなりすぎず、画面全体の見通しが向上するように思う。

## Tailwind CSS

最近話題の賛否両論あるCSSフレームワークがこちらである。

「ユーティリティ・ファースト」を謳っており、`class` や `className` に特定のクラスを当てていくことで、対応するCSSプロパティをてきようすることができるというものである。

例えば、Tailwind CSSを導入した状態でこのように書いたとする。

```html
<div class="bg-red-600">
	Hello
</div>
```

これはすなわち、以下のようなCSSプロパティを当てたのに相当する。

```css
bg-red-600 {
	background-color: #dc2626;
}
```

これによりCSSファイルの記述量が減り、さらに全体的にクラス名も短縮されて定義してあるので、スタイルの記述がある程度お手軽かつ高速になる。

私の知っている範囲だと、この手のプラグインでは他にもBootstrapというものがあった。Tailwind CSSはBootstrapよりも自由度が高く便利だとは思うものの、本来のCSSに比べると当然スタイルの幅は狭まってしまう。デフォルトでもそれなりに使えるが、例えば円状のグラデーションを追加したいと思ったら、`tailwind.config.cjs`をいじらないといけない。

```javascript
module.exports = {
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--gradient-color-stops))',
      }
    }
  }
}
```

https://github.com/tailwindlabs/tailwindcss/discussions/2599 より引用

また、本来のCSSを「極力書かせない」ようなフレームワークであるので、初心者には勧められない。

今回私は、スタイルシートをいっぱい書いて再現したい凝ったデザインも特にないのでTailwind CSSを採用した。とりあえずいい感じになればいいんだ。あとBootstrapは昔使ったから、今度は別のやつを使ってみたい、というのもある。

# 開発の工程

以上の技術を使うということを確認した上で、プロジェクトを作成した。

## プロジェクトの雛形

最近では新しく作成するアプリやウェブサイトについては、ボイラープレートを用いることもかなり多いと思う。例えば、Reactなら次のようなコマンドで手軽にReactアプリの雛形を作ってしまう。

```sh
yarn create react-app my-app
```

同じようなコマンドがAstroにもある。

```sh
yarn create astro
```

コマンドを実行すると、セットアップウィザードが始まり、ディレクトリ名、一緒に導入するフレームワーク、TypeScript使用などのオプションを設定できる。このような開発体験は私も結構好きである。昨今のコマンドラインツールは絵文字を表示したり見やすいシーケンスバーを表示したりと、256色の文字しか表示できない黒い画面を少しでも鮮やかにしようとしてくれているかのようだ。

このユーティリティの特徴としては、作成するウェブサイトのテンプレートを指定できることだろうか。

```
? Which template would you like to use? > - Use arrow-keys. Return to submit.
>   Just the basics (recommended)
    Blog
    Portfolio
    Documentation Site
    Empty project
```

こういう初心者に優しい（？）プロンプトも私は嫌いじゃない。これから楽しい開発体験が待っている！と開発者に期待させるような、良い演出だと私は思う。ターミナル上のプログレスバーが虹色に光るのも見ていて楽しい。Astroを使った開発者はなぜか Astronaut (宇宙飛行士) と呼ばれるのも、VTuberのファンにファンネームが存在するみたいなノリがあってなんだかワクワクする。

## ディレクトリ構成

プロジェクトを作成したら、ディレクトリに `cd` して依存関係をインストールして、開発サーバを立ち上げてみよう！と丁寧な導入が出力される。

```sh
cd my-astro-site
yarn
yarn start
```

開発用サーバを立ち上げて http://localhost:3000 にアクセスすると、~みんなの卒論のように~まっさらなウェブページが表示される。あまりにもまっさらで何にもない。私のような美的センス皆無の人間にこのようなまっさらなものを渡したら成果物もまっさらなのだが、それではリニューアル前と同じになってしまうので、スタイルシートについてはあとから考えることにする。

テンプレートからAstroのリポジトリを作成すると、最初からいくつかのディレクトリや設定ファイルが生成される。

- `src/*`: ソースコードが含まれる。
- `public/*`: ソースコードでない静的アセット。画像やフォントなど。
- `package.json`: プロジェクトの設定などが含まれる。JavaScriptのプロジェクトではおなじみのJSONファイル。
- `astro.config.mjs`: Astroのconfigファイル。
- `tsconfig.json`: TypeScriptを選択した場合に作成される。TypeScriptのトランスパイル時のオプション。

`src/*` ディレクトリの中身は次のような構造になる。

- `src/components/`: コンポーネント (部品) を配置する。
- `src/layouts/`: ページテンプレートを配置する。
- `src/pages/`: ページ本体を配置する。このディレクトリのファイル構造がほぼそのまま出力先のウェブサイトのルーティング構造になる。
- `src/styles/`: スタイルシートを配置する。

## Astroファイル

さて、Astroでは`.astro`ファイルという独自のマークアップ言語を用いてウェブサイトを記述することができる。`.astro`ファイルの構造はこのような感じで、モジュール拡張機能付きのJavaScript / TypeScriptのコード記述とHTMLを一緒に並べて書くような感じの見た目をしている。

```astro
---
import BaseHead from "../components/BaseHead.astro";
---

<html lang="ja">
	<head>
		<BaseHead />
	</head>
	<body>
		<h1>Hello</h1>
	</body>
</html>
```

見ての通り、ハイフンで囲まれた部分はJavaScriptのコードであり、その下はHTMLである。しかしこのJavaScriptのコードは、出力結果にスクリプトとしてバンドルされるのではなく、静的サイトに変換される。このあたりはReactのJSX記法とは前提条件が異なってくる。どちらかというとMarkdown形式の先頭に書くfrontmatterのほうが概念的に近い。

なので、クライアントサイドでスクリプトを実行するには、そのことをしっかりと明示するような設定を書かなければならない。通常のHTMLと同じように `<script>` が使えるので、それをテンプレート部分に記述するのも一つの方法である。他にもUIフレームワークと統合することでブラウザにJavaScriptを実行させることができる。

## React導入

今回、私はテーマのトグルスイッチを実装するのにReactが必要だった。別になくてもコンテンツサイトとしては機能するのだが、ダークモードに変更できたほうが目が疲れないだろうというちょっとした親切心である。

Astroはすでに様々な拡張機能が使えるようになっており、Reactの他にVueやAngularなど有名なUIフレームワークを導入することができる。

```sh
yarn astro add react
```

これだけでReact自体のインストールだけでなく、`astro.config.cjs`といった設定ファイルまで変更を加えてくれる。手動のインストールもそこまで複雑でなく、`@astrojs/react`, `react`, `react-dom`をyarnやnpmでインストールし、`astro.config.cjs` に追記するだけなのだが。

```javascript
import react from '@astrojs/react';

export default {
  // ...
  integrations: [react()],
}
```

## Tailwind CSS 導入

Tailwind CSSも拡張機能として手軽に統合可能である。

```sh
yarn astro add tailwind
```

これだけでユーティリティ・ファーストなスタイリング体験が可能である。特にレスポンシブ対応やダークモードの切り替えを実装する際のコード記述量がかなり少なくなったように感じる。というのも、例えば選択中のテーマに応じて `<main>` タグの背景とテキストの色を変更したい場合、次のように書くだけで良いのだ。

```html
<body class="bg-amber-50 dark:bg-stone-700 box-border text-slate-800 dark:text-slate-200 transition-colors duration-250" >
  <slot />
</body>
```

ここでは `dark:` という接頭辞がダークモードの場合に適用すべきスタイルであることを明示している。さらに色が変更された際のアニメーションも `transition-colors` と `duration-250` で記述しており、これだけで色がゆっくりと変化するアニメーションが適用される。

Tailwind CSSらしくクラスの数が恐ろしいことになっているが、なんかそろそろ慣れてきた気がする。同じことをCSSで実装しようとすると十数行のコードになるが、それをここまで短く書けるため、開発スピードは間違いなく上がる。特に私はオリジナルのCSSで完璧に再現したいデザインもないので、本当にこれで要件は満たせると思う。注意するべき点として、どういうクラスを書いたらどのような**CSSのプロパティが当てられるのか**をしっかり把握する必要がある。

## ランディングページ

ウェブサイトを訪れたときに最初に見るページは、ランディングページと呼ばれ、マーケティングの文脈ではかなり力を入れて作成されるようだ。私も少しでも私という人間の個人サイトに迷い込んだちゃんちゃらおかしい人々に楽しんでもらうために、インパクトのあるランディングページに仕上げたいと考えた。

このとき、どのようなことを書くか本当に迷った。例えば、巷のポートフォリオの例を眺めてみると、なにやらキャッチフレーズのようなものが書かれている場合がある。その一言は、そのサイトの人物がどのような職業や考えの人間で、どのような気持ちで仕事をしていきたいかなどを一言で表さんとする、いうなれば**座右の銘**のようなものが提示されるのだ。

これはこれで面白いが、私は座右の銘は書かなかった。私はシンプルに、そのへんのマイナーなSNSのユーザホームみたいなデザインで通すことにした。ただ、シンプルに自分の顔面を掲載しても何も面白くないので、友人が勝手に作成した用途不明の素材を使わせてもらった。

![謎素材](/lab/member/2109/me.jpg)

この眼力だけで十分インパクトはあると思うので、これ以上奇抜なことはせず、あとはシンプルにサイトのコンテンツへの誘導リンクと私の簡単なプロフィールのみを、色彩やデザインに気を使いながら書いていった。

このランディングページを作成する過程で、ウェブサイトの全体的なデザインも決定した。メインで使う色として薄めの青 (しばしば私に合う色としてあげられる) を採用し、ベースは薄い黄色を選んだ。ダークモードでは青は濃いものにし、黒は黒すぎないものを選んだ。こうして、まるで大学の数学の先生のスライド資料のようなデザインが完成したのである。BeamerでいうMadridとかそのあたりかな？

## テーマのトグルスイッチ

先に述べた通り、トグルスイッチをReactで実装した。クライアントサイドでスクリプトを実行させるにはAstroでも実現可能だが、Reactのほうが書きやすいと思った。Tailwindでは `dark:` 接頭辞に指定したデザインがダークモードの時に有効になる。

トグルスイッチの実装方法の方針は、Tailwindの公式ドキュメントにわかりやすい説明が載っているのでそれを参考にすることができる。

https://tailwindcss.com/docs/dark-mode

ネイティブのCSSでは`prefers-color-scheme`メディアクエリで、システムのカラースキームを検出して、ダークモードに自動スイッチできる。今回はユーザの好みでこれを自由に変更できるようにしたいので、以下のようにドキュメントのルート要素にクラスを追加したり削除したりする方法を取る。

```js
  const [theme, setTheme] = useState(() => { /* ... */});
  useEffect(() => {
    const root = document.documentElement;
    if (theme === 'light') {
      root.classList.remove('dark');
    } else {
      root.classList.add('dark');
    }
  }, [theme]);
```

これはテーマトグルスイッチのコンポーネントの内部のコードである。 今回はテーマの設定は`localStorage`に保存する戦略を取っており、 `theme` の初期値は最初にこの`localStorage`を参照する。値が見つからなければシステムのカラースキームを参照し、それも見つからなければ、適当に`light`とかで初期値を決め打ちする、というスタイルだ。

ページを読み込んだときに、`localStorage` を参照して、自動でカラーを変更する処理も追加しておく。こうしておかないといったんライトモードでコンポーネント全体をレンダリングして、`localStorage` が書き換えられたときに `useEffect` が発火してダークテーマが適用されたりしてしまう。表示のされ方としては、さっきまでダークモードだったのに、ページ遷移をしたら一旦全体が明るくなって、また暗くなるという感じになるため、目に悪い。

```js
<script is:inline>
    const root = document.documentElement;
    const localStorageTheme = localStorage.getItem('theme');
    if (localStorageTheme !== null) {
        if (localStorageTheme === 'light') {
            root.classList.remove('dark');
        } else {
            root.classList.add('dark');
        }
    }
</script>
```

## プロフィールページ

自信の経歴や使ったことのある言語・フレームワークについてまとめたページを"About"としてサイトに置いておく。大抵のブログサイトのライターの自己紹介には書き手の赤裸々な思いや好きなことについて割りと自由に書き連ねたりしているが、私はそういう赤裸々な思いをブログのエントリーにバンバン載せているので、特に面白みのない履歴書スタイルで書き上げた。

自画像を投入したいが、さすがにさっきの眼光を使い回すのは気が引けたので、自分のGoogle Photosを探索した。だがいくら探しても自分が椅子に座ってキーボードを叩きコーディングに勤しんでいるカットが見つからない。代替手段として、初代プレステぶりにゲーセンで「電車でGO」を楽しんでいる私の画像を貼り付けておいた。電車でGOだと言わなければなにやら薄暗い部屋で複数のディスプレイに囲まれながらハッキング的なことをしているように見えなくもない。単にローディング画面が表示されているだけなのだが。

![ハッカー?](/lab/member/2109/me-operating-train.jpg)

## 既存コンテンツを移行

あとは旧ウェブサイトの移行を行う。

Astroを選んでみた特徴の一つとして、Markdown形式のページをシームレスに静的ウェブサイトとして出力する事ができるオールインワンのフレームワークであるという点が挙げられる。別の場所でも書いたかもしれないが、私は基本的にHTMLを書くのを面倒くさがっている。代わりに記事の内容にフォーカスしたMarkdown形式を好んでおり、これまでずっとMarkdownでブログを書く方法を模索し続けてきた。Markdownパーサの自作に始まり、Pandocの発見、MarkdownとLaTeX / PDFの変換やMarkdownによるスライド資料作成など、これまで効率性を重視した~無駄な~努力を重ねてきた。Astroの選定はこの営みの（現時点での）最終形態とも言える。

記事の本文そのものをいじる必要はなかったが、苦労したのは画像の表示である。画像のパスの設定には気を使う必要があり、Markdown形式でページを作成すると、Astroは `public` ディレクトリにある画像に対する絶対パスでしか画像を読み込んでくれない。しかし既存のMarkdownファイルの画像のパス指定は記事からの相対パスで書かれていたので、これを調整する必要があった。このあと実際のサーバにデプロイするときも画像やCSSアセットなどで一悶着あったのだが、このあたりは**Vimの優秀な編集機能により**そこまで苦労せずに修正できた。

## デプロイ

最終的なウェブページを出力するには `yarn build` コマンドを用いる。すると予め設定したディレクトリ (デフォルトでは `dist/`) にHTMLファイルやJSファイルが生成される。これをサーバに持っていけば基本的にウェブサイトとして正常に表示されるはずである。

生成されたコードを見てみると、JavaScriptの変数名が一文字だったり、そもそも改行もインデントもされていなかったりと、明らかに機械的に生成したような見た目をしている。人間はAstroファイルやReactの書き方でウェブページを記述し、成果物は人間が読むのを想定しない効率重視の形式で出力される。

ちょっと引っかかった点として、ローカルサーバで開発するときは `http://localhost:3000/` でホストしていたので、`<a>` リンクや `<img>` のパスなどをルート `/` を起点にして書けばよかったのだが、ゼミのサーバにホストするとルートは `/lab/member/2109/` になるので、先程のリンクや画像へのパスはこれをすべてパスの直線に書いて指定しないといけなかった。

編集作業自体は最強 (所感) のテキストエディタを使用しているのでそこまで大変ではない (これを使い慣れていない GUIエディタでやっていたらどうなっていたことだろう) が、今度はローカルサーバで画像が表示されなかったりビルドがうまくいかなかったりすることが懸念される。

その場合は `astro.config.mjs` を編集して、次のようにすればよい。

```js
export default defineConfig({
  site: 'http://kawai.onamaeweb.jp',
  base: '/lab/member/2109',
  /* --- snif --- */
})
```

個人的にはReact Routerのように、ルーティングの起点 (ここでは `base` 属性) を変更すれば、サイト内部のルーティングやパス指定もビルド時に自動で調整してくれる機能があればいいなあと思う。ただAstroは独自のルーティングライブラリを持たず、ブラウザネイティブの `<a>` を使わせると書いてあったので、そのような使い方は想定していないのかもしれない。  今のところこのような一工夫はGitHub Pagesくらいしか使い所がなさそうだ。

`dist/` に生成されたファイルたちをそのままサーバに転送すればデプロイ完了なのだが、以前は自作の[Pythonスクリプト](https://github.com/taitohaga/ftpu)を導入してコマンド一行で一括更新していた。今回もそうしようと思ったのだが、Pythonのスクリプト本体を実行するためのバッチファイルを作成してパスを通して `package.json` にスクリプトを登録するのがちょっと面倒だったので、シンプルにFFFTPを使った。このあたりの設定もそのうち整えるつもりではある。理想としては、こんな感じでYarnと統合してコマンド一行でデプロイまで自動化したい。

```sh
yarn deploy
> cd dist && ftpu update
```

# 成果物

ついに完成したのが今皆さんが見ているこのウェブサイトである。ライトモードは背景に黄色を選択してポップ（？）な感じを演出し、ダークモードは一気にギークな雰囲気に仕立てた。

![新しいウェブサイト](/lab/member/2109/images/new-website.png)

なかなか出来は悪くないんじゃないかと思う。以前のあのデザインに比べて色が増え、全体的に見やすくなった。もちろんレスポンシブ対応で、スマホで開くとヘッダーメニューの文字が消失したり、コンテンツが縦一列に並んだりする。モードトグルスイッチもちゃんと動いているはずだ。

# 公開後の機能追加

とりあえず公開したものの、実際にブログ記事を閲覧したり、複数のデバイスでウェブサイトを表示してみるうちに、いくつもの問題点が出てきた。

気になったのは目次を実装していないことだった。目次を表示しておきその部分にすぐに飛べたほうが効率的に記事を閲覧できるはず。記事全体の構成の見通しも良くなり、どういう内容が書かれているのか瞬時にわかるようになるはずだ。

一方でウェブサイト全体をスマホや小さい画面で表示する前提で設計したため、もっと解像度の高い画面・大きい画面で開いた際、コンテンツが真ん中に集中しすぎてしまう。大画面で表示するなら大画面をもう少し有効に活用したほうが良いかと考えた。

気になったのは以上の2点なので、一つ一つ機能追加・修正をしていく。

# 目次の追加

わりかし長めな記事も存在するので、それらを読むのに目次は表示できたほうがよいと考えた。問題はどこに表示するかだが、いくつか方針がある。

## サイドに固定する目次

例えば、記事の冒頭に載せておくのは非常に実装しやすい。このウェブサイトの場合、 `BlogPost.astro` にブログ記事のレイアウトが定義されており、この中に目次を表示するタグを追加すれば良い。だがこのスタイルは本文を読んでいる最中に目次を参照できない。メジャーなブログ投稿サイトであるQiitaでは右端に常に目次が表示されていて、読んでいるのがいまどの部分かすぐに分かる。これの形式を採用したいと考えた。

もちろん、目次を常に横に表示するには、CSSプロパティの `position: sticky` などが使用できる。Tailwind CSSでは次のように書けば良い。

```jsx
<div class="flex">
  <div>
    {/*メインコンテンツ*/}
  </div>
  <div>
    <div className="sticky top-4rem">
    </div>
  </div>
</div>
```

## トグルメニューとボタン

スマホ表示を考えると、横に目次を表示するのはナンセンスだ。かといって、個人的に本文を読み始めると目次が参照できないのは不便なので、トグルスイッチを右下に固定して、それを押すとメニューが展開される、というUIを構築することにした。

まずそのトグルスイッチだが、クライアントサイドでスクリプトを実行する必要が出てくるので、Reactのコンポーネントとして作成する。このコンポーネントのファイル名を `TocToggler.tsx` という名前で作成したとすると、このコンポーネントは次の3つの要素を含む必要がある。

- ボタン本体
- 目次のメニュー
- 背景ぼかし

目次メニューを開くためにトグルスイッチを押すと、メニューを展開すると同時にメインコンテンツの方を若干ぼやけさせて表示したい。背景ぼかしはそれを実現するための要素である。

```jsx
import { useState } from 'react';

export default function TocToggler(props: TocTogglerProps) {
    const [tocOpen, setTocOpen] = useState(false);
    
	/* 省略 */
	return (
	    <div>
	        <div></div> {/*メニュー*/}
	        <div></div> {/*トグルスイッチ*/}
	        <div></div> {/*背景ぼかし*/}
	    </div>
	);
}
```

一つひとつ、どのようにCSSプロパティを当てればよいか見ていこう。

長い記事を表示しようとすると目次の項目数が多くなり、スマートフォンだと画面をはみ出してしまう可能性がある。 `overflow-y: auto` で内部のコンテンツの量に応じて自動でスクロールバーの表示・非表示を切り替えることができる。このとき、目次メニューのサイズ自体も指定する必要がある。画面の大きさに合わせて目次メニューのサイズも変更したいので、 `vh` や `vw` を使うと良い。

```jsx
<div className="max-w-[90vw] max-h-[calc(100vh-10rem)] overflow-y-auto">
<ul>
    <li>Heading 1</li>
    <li>Heading 2</li>
    <li>Heading 3</li>
</ul>
</div>
```

これで画面のサイズに合わせたメニューを表示してくれるようになった。

次にトグルスイッチ本体だが、これは好みの形状・見た目になるようにCSSを割り当てるだけで良い。このサイトでは次のようにした。`onClick` 属性についてはまた後で書く。

```jsx
<div className="rounded-full w-12 h-12 mr-0">
	<button class="rounded-full ml-auto w-full h-full" onClick={toggleToc}> {/*省略*/} </button>
</div>
```

最後に背景ぼかし。背景をぼかすにはCSSの `backdrop-filter` プロパティが便利だった。Tailwind CSSだと次の通りになる。また背景全体を覆いたいので、 `position: fixed` と位置指定も必要だ。

```jsx
<div
	className="fixed top-0 left-o w-full h-full backdrop-blur-xl bg-blue/30"
>
</div>
```

この3つを用意したら、それらをまとめてコンポーネントとして外部に公開するが、このコンポーネント自体は大きい画面では表示したくない。代わりに目次をサイドに固定させたいのだ。要素を非表示にするには `display: hidden` とすればよい。さらにこのコンポーネント自体を右下に固定するためには、`position: fixed` と `right: 20px` などのように設定する必要がある。

```jsx
<div
    className="lg:hidden flex flex-col items-end gap-4 fixed right-[20px] bottom-[20px]"
>
	{/* 省略 */}
</div>
```

ここまできたら、トグルスイッチの動きを設定しよう。

実装にはReactのステートを用いる。Reactの `useState` を使ってコンポーネントに状態を追加し、メニューボタンがクリックされたときに実行する関数を定義する。

```jsx
import { useState } from 'react';

export default function TocToggler(props: TocTogglerProps) {
	const [tocOpen, setTocOpen] = useState(false);
	const toggleToc = () => {
		setTocOpen(cur => !cur)
	};

	return (
		<div className="...">
			<div className={`${ tocOpen ? 'block' : 'hidden' }`}></div>
			<div className="rounded-full ...">
				<button className="..." onClick={toggleToc} > {/*省略*/} </div>
			</div>
			<div className={`${ tocOpen ? 'block' : 'hidden' }`} onClick={toggleToc}></div>
		</div>
	)
}
```

見てわかる通り、コンポーネントのステート `tocOpen` の値によって適用するクラスを変更している。ところで、このコンポーネントはクライアントサイドでコンポーネントの表示・非表示を切り替えるので、ブラウザのスクリプトを読み込んでもらう必要がある。

```astro
<TocToggler client:load />
```

## 目次の自動生成

コンピュータで執筆している限り、目次の自動生成はあって当たり前である。AstroのMarkdown処理では、`Astro.props.headings` に以下のような形式でヘディングのリストにアクセスできる。

```js
[
  {
    text: "Heading 1",
    slug: "Heading-1",
    depth: 1,
  },
  {
    text: "Heading 2",
    slug: "Heading-2",
    depth: 1,
  },
  {
    text: "Heading 3",
    slug: "Heading-3",
    depth: 2,
  },
]
```

これを元にして目次を表示する。まずはこれをそのまま次のようなコードで箇条書きリストにしようとする。

```jsx
<ul>
  {
    Astro.props.headings.map(heading => {
      return <li><a href={`#${heading.slug}`}>{heading.text}</a></li>
    })
  }
</ul>
```

これでとりあえず目次は作成できるが、サブセクションやサブサブセクションまで同列に表示されてしまう。本来なら、サブセクション見出しはセクション見出しよりも1段インデントされるべきだ。手っ取り早い方法は `depth` の値に応じて左にマージンを入れることだが、これではHTMLセマンティック的に好ましくない。構造的に、`depth` の値が大きい項目はその前の要素と同じ `depth` を持つなら同列の `<ul>` に配置されるべきだし、小さい `depth` を持つなら新しく `<ul>` を作成するべきだ。

これを実現するには `depth` 属性を持つオブジェクトのリストを木構造にデシリアライズする処理を書かなければならない。これはちょっと面倒だと思った。久しぶりにアルゴリズムっぽいことを考えなければならないからだ。

私は何度か、そのような処理を記述するのを回避できないかと調べた。一番楽そうだったのは `rehype-toc` プラグインを追加することだったが、これで生成される目次はMarkdown記法であり、しかも記事の冒頭に挿入される。私はそれを単独で入手してなおかつコンポーネントとして入手したいので、これでは実現できない。ちょっとしたアルゴリズムを行わざるを得なかった。

私はこの処理を実装するために、次の二段階に分けて考えた。

- ヘディングリストを木構造オブジェクトに変換する
- 木構造オブジェクトをJSXノードに展開する

まず、木構造オブジェクトに変換するために次のようなノードオブジェクト型を定義しよう。

```typescript
interface HeadingNode {
  text: string;
  slug: string;
  depth: number;
  parent?: HeadingNode;
  children: HeadingNode[];
}
```

Astroのヘディングオブジェクトに `parent` と `children` を追加した。それぞれ親のノードと子のノードを示している。最初、ReactのAPIを直接利用しようと考えたが、Vanilla JSのWeb APIでいう `appendChild` メソッドに相当するものが `ReactNode` にもあるのかがわからなかった（もしあるのなら教えて欲しい）。なのでこのようなノードオブジェクトを自分で定義して、あとはJSXの書き方でReactのコンポーネントを構築していく。

木構造にするには、次のように処理すれば良い。

- rootノードを作成する
- rootノードをlastノードとする
- 与えられたヘディングの配列の要素それぞれに対し、以下を実行
  - lastのdepthと対象の要素のdepthを比較
    - lastの要素のdepth > 対象の要素のdepthなら、対象の要素からHeadingNode型オブジェクトを作成し、lastのchildrenに追加。これをlastとする
    - lastの要素のdepth === 対象の要素のdepthなら、対象の要素からHeadingNode型オブジェクトを作成し、lastのparentのchilrenに追加。これをlastとする
    - lastの要素のdepth < 対処の要素のdepthなら、lastのparentをparとし、parのparentが存在する限り以下を繰り返し実行
      - parのdepthと対象の要素のdepthを比較
        - 等しければ、対象の要素からHeadingNode型オブジェクトを作成し、parのparentのchildrenに追加。これをlastとし、ループを抜ける
      - parのparentをparとする

このサイトにおける実装は [ここ](https://github.com/taitohaga/lab-website/commit/145e11b935b634049bba9270778d05b3cc217baf#diff-0f6bd3f0b5e48a667ee9574bfb3aac8827c2aeb42d55ffe9594860d7728f6be4) で確認することができる。日本語よりJavaScriptのソースコードで見たほうが絶対にわかりやすい。

`HeadingNode` 型を用いた木構造オブジェクトが作成できたら、それを元にJSXの書き方でReactのノードに変換する。これは関数を再帰的に呼び出せば実現できる。

```jsx
const renderToc = (headingNode: HeadingNode) => {
  return (
    <li key={headingNode.slug}>
      <>
        <a href={`#${headingNode.slug}`}>
          <div className="...">
            <span className="...">{headingNode.text}</span>
          </div>
        </a>
        {headingNode.children length !== 0 ? (
          <ul>
          {headingNode.children.map((node: HeadingNode) => renderToc(node))}
          </ul>
        ) : (
          <></>
        )}
      </>
    </li>
  );
};
```

## 画面サイズで切り替える

ここまでで作成したコンポーネントを、画面のサイズに従って切り替えたい。Tailwind CSSでの画面の横幅の設定について見てみよう。ブレークポイントと最小サイズは次の通り。

| 接頭辞 | 最小幅 | CSS | 主なデバイス |
|---|---|---|---|
| `sm` | 640px | `@media (min-width: 640px) { ... }` | スマホ |
| `md` | 768px | `@media (min-width: 768px) { ... }` | タブレット |
| `lg` | 1024px | `@media (min-width: 1024px) { ... }` | PC |
| `xl` | 1280px | `@media (min-width: 1280px) { ... }` | 解像度高めのPC |
| `2xl` | 1536px | `@media (min-width: 1536px) { ... }` | 4K |

クラス名にこれらの接頭辞を付け加えると、その画面サイズ以上の表示領域でクラスのスタイルが適用される。つまり、最初にスマホでの表示の仕方を考えておき、画面が大きくなるに連れてそれに合わせて表示方法を変えさせる、というスタンスを取っているようだ。

このウェブサイトでは `lg` をブレークポイントとする。

```jsx
<div>
  <div>
    {/*メインコンテンツ*/}
  </div>
  <div>
    <div class="hidden lg:block ...">
      {/*目次 (サイドバー)*/}
    </div>
    <TocToggler />
  </div>
</div>
```

`block` というクラスはCSSでいう `display: block` に、 `hidden` は先程も登場したが `display: hidden` になるので、これによって画面サイズが `lg` 以上のときにサイドバー型の目次が表示され、それ以外のときは非表示に切り替わる。これらのブレークポイントは、そのスタイルが適用される最小の画面サイズを表していることを留意する必要がある。

# 大きめ画面に対応

先程 `lg` をブレークポイントとするときの画面のレイアウト変更を実装したが、どうせならブログ記事のページ以外の部分も大きめの画面に対応させよう。

例えば、トップページの私のプロフィールやコンテンツのスタックは、画面サイズに応じて列数を変更したほうが表示領域を広く使えて良い。

```jsx
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
  <ContentBox />
  <ContentBox />
  <ContentBox />
</div>
```

横幅が広いなら、私の顔写真とプロフィールカードを横に並べるよう変更するのも良さそうだ。

```jsx
<div class="flex flex-col lg:flex-row content-center justify-center py-5 lg:gap-10">
  <div class="flex flex-col content-center justify-center">
    <img
      class="object-cover rounded-full w-40 h-40 m-auto md:w-60 md:h-60"
      src="/lab/member/2109/me.jpg"
      alt="Me"
    />
  </div>
  <div class="...">
    {/* ... */}
  </div>
</div>
```

画面サイズが `lg` より大きいときにフレックスボックスの主軸をrowに変更している。